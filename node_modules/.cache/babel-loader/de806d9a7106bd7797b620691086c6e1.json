{"remainingRequest":"C:\\Users\\Acer\\Desktop\\pmm\\pm25-vue\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Acer\\Desktop\\pmm\\pm25-vue\\node_modules\\vuetify\\lib\\components\\VSparkline\\helpers\\core.js","dependencies":[{"path":"C:\\Users\\Acer\\Desktop\\pmm\\pm25-vue\\node_modules\\vuetify\\lib\\components\\VSparkline\\helpers\\core.js","mtime":499162500000},{"path":"C:\\Users\\Acer\\Desktop\\pmm\\pm25-vue\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Acer\\Desktop\\pmm\\pm25-vue\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["export function genPoints(values, boundary) {\n  const {\n    minX,\n    maxX,\n    minY,\n    maxY\n  } = boundary;\n  const totalValues = values.length;\n  const maxValue = Math.max(...values);\n  const minValue = Math.min(...values);\n  const gridX = (maxX - minX) / (totalValues - 1);\n  const gridY = (maxY - minY) / (maxValue - minValue || 1);\n  return values.map((value, index) => {\n    return {\n      x: minX + index * gridX,\n      y: maxY - (value - minValue) * gridY + +(index === totalValues - 1) * 0.00001 - +(index === 0) * 0.00001,\n      value\n    };\n  });\n}\nexport function genBars(values, boundary) {\n  const {\n    minX,\n    maxX,\n    minY,\n    maxY\n  } = boundary;\n  const totalValues = values.length;\n  let maxValue = Math.max(...values);\n  let minValue = Math.min(...values);\n  if (minValue > 0) minValue = 0;\n  if (maxValue < 0) maxValue = 0;\n  const gridX = maxX / totalValues;\n  const gridY = (maxY - minY) / (maxValue - minValue);\n  const horizonY = maxY - Math.abs(minValue * gridY);\n  return values.map((value, index) => {\n    const height = Math.abs(gridY * value);\n    return {\n      x: minX + index * gridX,\n      y: horizonY - height + +(value < 0) * height,\n      height,\n      value\n    };\n  });\n}",{"version":3,"sources":["../../../../src/components/VSparkline/helpers/core.ts"],"names":[],"mappings":"AAEA,OAAM,SAAA,SAAA,CAAA,MAAA,EAAA,QAAA,EAEc;AAElB,QAAM;AAAA,IAAA,IAAA;AAAA,IAAA,IAAA;AAAA,IAAA,IAAA;AAAoB,IAAA;AAApB,MAAN,QAAA;AACA,QAAM,WAAW,GAAG,MAAM,CAA1B,MAAA;AACA,QAAM,QAAQ,GAAG,IAAI,CAAJ,GAAA,CAAS,GAA1B,MAAiB,CAAjB;AACA,QAAM,QAAQ,GAAG,IAAI,CAAJ,GAAA,CAAS,GAA1B,MAAiB,CAAjB;AAEA,QAAM,KAAK,GAAG,CAAC,IAAI,GAAL,IAAA,KAAiB,WAAW,GAA1C,CAAc,CAAd;AACA,QAAM,KAAK,GAAG,CAAC,IAAI,GAAL,IAAA,KAAkB,QAAQ,GAAT,QAAC,IAAhC,CAAc,CAAd;AAEA,SAAO,MAAM,CAAN,GAAA,CAAW,CAAA,KAAA,EAAA,KAAA,KAAiB;AACjC,WAAO;AACL,MAAA,CAAC,EAAE,IAAI,GAAG,KAAK,GADV,KAAA;AAEL,MAAA,CAAC,EACC,IAAI,GACJ,CAAC,KAAK,GAAN,QAAA,IADA,KAAA,GAEA,EAAE,KAAK,KAAK,WAAW,GAAvB,CAAA,IAFA,OAAA,GAGA,EAAE,KAAK,KAAP,CAAA,IANG,OAAA;AAOL,MAAA;AAPK,KAAP;AADF,GAAO,CAAP;AAWD;AAED,OAAM,SAAA,OAAA,CAAA,MAAA,EAAA,QAAA,EAEc;AAElB,QAAM;AAAA,IAAA,IAAA;AAAA,IAAA,IAAA;AAAA,IAAA,IAAA;AAAoB,IAAA;AAApB,MAAN,QAAA;AACA,QAAM,WAAW,GAAG,MAAM,CAA1B,MAAA;AACA,MAAI,QAAQ,GAAG,IAAI,CAAJ,GAAA,CAAS,GAAxB,MAAe,CAAf;AACA,MAAI,QAAQ,GAAG,IAAI,CAAJ,GAAA,CAAS,GAAxB,MAAe,CAAf;AAEA,MAAI,QAAQ,GAAZ,CAAA,EAAkB,QAAQ,GAAR,CAAA;AAClB,MAAI,QAAQ,GAAZ,CAAA,EAAkB,QAAQ,GAAR,CAAA;AAElB,QAAM,KAAK,GAAG,IAAI,GAAlB,WAAA;AACA,QAAM,KAAK,GAAG,CAAC,IAAI,GAAL,IAAA,KAAiB,QAAQ,GAAvC,QAAc,CAAd;AACA,QAAM,QAAQ,GAAG,IAAI,GAAG,IAAI,CAAJ,GAAA,CAAS,QAAQ,GAAzC,KAAwB,CAAxB;AAEA,SAAO,MAAM,CAAN,GAAA,CAAW,CAAA,KAAA,EAAA,KAAA,KAAiB;AACjC,UAAM,MAAM,GAAG,IAAI,CAAJ,GAAA,CAAS,KAAK,GAA7B,KAAe,CAAf;AAEA,WAAO;AACL,MAAA,CAAC,EAAE,IAAI,GAAG,KAAK,GADV,KAAA;AAEL,MAAA,CAAC,EAAE,QAAQ,GAAR,MAAA,GACD,EAAE,KAAK,GAAP,CAAA,IAHG,MAAA;AAAA,MAAA,MAAA;AAKL,MAAA;AALK,KAAP;AAHF,GAAO,CAAP;AAWD","sourcesContent":["import { Point, Boundary, Bar } from '../VSparkline'\n\nexport function genPoints (\n  values: number[],\n  boundary: Boundary\n): Point[] {\n  const { minX, maxX, minY, maxY } = boundary\n  const totalValues = values.length\n  const maxValue = Math.max(...values)\n  const minValue = Math.min(...values)\n\n  const gridX = (maxX - minX) / (totalValues - 1)\n  const gridY = (maxY - minY) / ((maxValue - minValue) || 1)\n\n  return values.map((value, index) => {\n    return {\n      x: minX + index * gridX,\n      y:\n        maxY -\n        (value - minValue) * gridY +\n        +(index === totalValues - 1) * 0.00001 -\n        +(index === 0) * 0.00001,\n      value,\n    }\n  })\n}\n\nexport function genBars (\n  values: number[],\n  boundary: Boundary\n): Bar[] {\n  const { minX, maxX, minY, maxY } = boundary\n  const totalValues = values.length\n  let maxValue = Math.max(...values)\n  let minValue = Math.min(...values)\n\n  if (minValue > 0) minValue = 0\n  if (maxValue < 0) maxValue = 0\n\n  const gridX = maxX / totalValues\n  const gridY = (maxY - minY) / (maxValue - minValue)\n  const horizonY = maxY - Math.abs(minValue * gridY)\n\n  return values.map((value, index) => {\n    const height = Math.abs(gridY * value)\n\n    return {\n      x: minX + index * gridX,\n      y: horizonY - height +\n        +(value < 0) * height,\n      height,\n      value,\n    }\n  })\n}\n"],"sourceRoot":""}]}
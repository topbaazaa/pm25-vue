{"remainingRequest":"C:\\Users\\Acer\\Desktop\\pmm\\pm25-vue\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Acer\\Desktop\\pmm\\pm25-vue\\node_modules\\vuetify\\lib\\mixins\\validatable\\index.js","dependencies":[{"path":"C:\\Users\\Acer\\Desktop\\pmm\\pm25-vue\\node_modules\\vuetify\\lib\\mixins\\validatable\\index.js","mtime":499162500000},{"path":"C:\\Users\\Acer\\Desktop\\pmm\\pm25-vue\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Acer\\Desktop\\pmm\\pm25-vue\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["// Mixins\nimport Colorable from '../colorable';\nimport Themeable from '../themeable';\nimport { inject as RegistrableInject } from '../registrable'; // Utilities\n\nimport { deepEqual } from '../../util/helpers';\nimport { consoleError } from '../../util/console';\nimport mixins from '../../util/mixins';\n/* @vue/component */\n\nexport default mixins(Colorable, RegistrableInject('form'), Themeable).extend({\n  name: 'validatable',\n  props: {\n    disabled: Boolean,\n    error: Boolean,\n    errorCount: {\n      type: [Number, String],\n      default: 1\n    },\n    errorMessages: {\n      type: [String, Array],\n      default: () => []\n    },\n    messages: {\n      type: [String, Array],\n      default: () => []\n    },\n    readonly: Boolean,\n    rules: {\n      type: Array,\n      default: () => []\n    },\n    success: Boolean,\n    successMessages: {\n      type: [String, Array],\n      default: () => []\n    },\n    validateOnBlur: Boolean,\n    value: {\n      required: false\n    }\n  },\n\n  data() {\n    return {\n      errorBucket: [],\n      hasColor: false,\n      hasFocused: false,\n      hasInput: false,\n      isFocused: false,\n      isResetting: false,\n      lazyValue: this.value,\n      valid: false\n    };\n  },\n\n  computed: {\n    computedColor() {\n      if (this.disabled) return undefined;\n      if (this.color) return this.color; // It's assumed that if the input is on a\n      // dark background, the user will want to\n      // have a white color. If the entire app\n      // is setup to be dark, then they will\n      // like want to use their primary color\n\n      if (this.isDark && !this.appIsDark) return 'white';else return 'primary';\n    },\n\n    hasError() {\n      return this.internalErrorMessages.length > 0 || this.errorBucket.length > 0 || this.error;\n    },\n\n    // TODO: Add logic that allows the user to enable based\n    // upon a good validation\n    hasSuccess() {\n      return this.internalSuccessMessages.length > 0 || this.success;\n    },\n\n    externalError() {\n      return this.internalErrorMessages.length > 0 || this.error;\n    },\n\n    hasMessages() {\n      return this.validationTarget.length > 0;\n    },\n\n    hasState() {\n      if (this.disabled) return false;\n      return this.hasSuccess || this.shouldValidate && this.hasError;\n    },\n\n    internalErrorMessages() {\n      return this.genInternalMessages(this.errorMessages);\n    },\n\n    internalMessages() {\n      return this.genInternalMessages(this.messages);\n    },\n\n    internalSuccessMessages() {\n      return this.genInternalMessages(this.successMessages);\n    },\n\n    internalValue: {\n      get() {\n        return this.lazyValue;\n      },\n\n      set(val) {\n        this.lazyValue = val;\n        this.$emit('input', val);\n      }\n\n    },\n\n    shouldValidate() {\n      if (this.externalError) return true;\n      if (this.isResetting) return false;\n      return this.validateOnBlur ? this.hasFocused && !this.isFocused : this.hasInput || this.hasFocused;\n    },\n\n    validations() {\n      return this.validationTarget.slice(0, Number(this.errorCount));\n    },\n\n    validationState() {\n      if (this.disabled) return undefined;\n      if (this.hasError && this.shouldValidate) return 'error';\n      if (this.hasSuccess) return 'success';\n      if (this.hasColor) return this.computedColor;\n      return undefined;\n    },\n\n    validationTarget() {\n      if (this.internalErrorMessages.length > 0) {\n        return this.internalErrorMessages;\n      } else if (this.successMessages.length > 0) {\n        return this.internalSuccessMessages;\n      } else if (this.messages.length > 0) {\n        return this.internalMessages;\n      } else if (this.shouldValidate) {\n        return this.errorBucket;\n      } else return [];\n    }\n\n  },\n  watch: {\n    rules: {\n      handler(newVal, oldVal) {\n        if (deepEqual(newVal, oldVal)) return;\n        this.validate();\n      },\n\n      deep: true\n    },\n\n    internalValue() {\n      // If it's the first time we're setting input,\n      // mark it with hasInput\n      this.hasInput = true;\n      this.validateOnBlur || this.$nextTick(this.validate);\n    },\n\n    isFocused(val) {\n      // Should not check validation\n      // if disabled\n      if (!val && !this.disabled) {\n        this.hasFocused = true;\n        this.validateOnBlur && this.validate();\n      }\n    },\n\n    isResetting() {\n      setTimeout(() => {\n        this.hasInput = false;\n        this.hasFocused = false;\n        this.isResetting = false;\n        this.validate();\n      }, 0);\n    },\n\n    hasError(val) {\n      if (this.shouldValidate) {\n        this.$emit('update:error', val);\n      }\n    },\n\n    value(val) {\n      this.lazyValue = val;\n    }\n\n  },\n\n  beforeMount() {\n    this.validate();\n  },\n\n  created() {\n    this.form && this.form.register(this);\n  },\n\n  beforeDestroy() {\n    this.form && this.form.unregister(this);\n  },\n\n  methods: {\n    genInternalMessages(messages) {\n      if (!messages) return [];else if (Array.isArray(messages)) return messages;else return [messages];\n    },\n\n    /** @public */\n    reset() {\n      this.isResetting = true;\n      this.internalValue = Array.isArray(this.internalValue) ? [] : undefined;\n    },\n\n    /** @public */\n    resetValidation() {\n      this.isResetting = true;\n    },\n\n    /** @public */\n    validate(force = false, value) {\n      const errorBucket = [];\n      value = value || this.internalValue;\n      if (force) this.hasInput = this.hasFocused = true;\n\n      for (let index = 0; index < this.rules.length; index++) {\n        const rule = this.rules[index];\n        const valid = typeof rule === 'function' ? rule(value) : rule;\n\n        if (typeof valid === 'string') {\n          errorBucket.push(valid);\n        } else if (typeof valid !== 'boolean') {\n          consoleError(`Rules should return a string or boolean, received '${typeof valid}' instead`, this);\n        }\n      }\n\n      this.errorBucket = errorBucket;\n      this.valid = errorBucket.length === 0;\n      return this.valid;\n    }\n\n  }\n});",{"version":3,"sources":["../../../src/mixins/validatable/index.ts"],"names":[],"mappings":"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","sourcesContent":["// Mixins\nimport Colorable from '../colorable'\nimport Themeable from '../themeable'\nimport { inject as RegistrableInject } from '../registrable'\n\n// Utilities\nimport { deepEqual } from '../../util/helpers'\nimport { consoleError } from '../../util/console'\nimport mixins from '../../util/mixins'\n\n// Types\nimport { PropValidator } from 'vue/types/options'\nexport type VuetifyRuleValidator = (value: any) => string | boolean\nexport type VuetifyMessage = string | string[]\nexport type VuetifyRuleValidations = (VuetifyRuleValidator | string)[]\n\n/* @vue/component */\nexport default mixins(\n  Colorable,\n  RegistrableInject('form'),\n  Themeable\n).extend({\n  name: 'validatable',\n\n  props: {\n    disabled: Boolean,\n    error: Boolean,\n    errorCount: {\n      type: [Number, String],\n      default: 1,\n    },\n    errorMessages: {\n      type: [String, Array],\n      default: () => [],\n    } as PropValidator<VuetifyMessage>,\n    messages: {\n      type: [String, Array],\n      default: () => [],\n    } as PropValidator<VuetifyMessage>,\n    readonly: Boolean,\n    rules: {\n      type: Array,\n      default: () => [],\n    } as PropValidator<VuetifyRuleValidations>,\n    success: Boolean,\n    successMessages: {\n      type: [String, Array],\n      default: () => [],\n    } as PropValidator<VuetifyMessage>,\n    validateOnBlur: Boolean,\n    value: { required: false },\n  },\n\n  data () {\n    return {\n      errorBucket: [] as string[],\n      hasColor: false,\n      hasFocused: false,\n      hasInput: false,\n      isFocused: false,\n      isResetting: false,\n      lazyValue: this.value,\n      valid: false,\n    }\n  },\n\n  computed: {\n    computedColor (): string | undefined {\n      if (this.disabled) return undefined\n      if (this.color) return this.color\n      // It's assumed that if the input is on a\n      // dark background, the user will want to\n      // have a white color. If the entire app\n      // is setup to be dark, then they will\n      // like want to use their primary color\n      if (this.isDark && !this.appIsDark) return 'white'\n      else return 'primary'\n    },\n    hasError (): boolean {\n      return (\n        this.internalErrorMessages.length > 0 ||\n        this.errorBucket.length > 0 ||\n        this.error\n      )\n    },\n    // TODO: Add logic that allows the user to enable based\n    // upon a good validation\n    hasSuccess (): boolean {\n      return (\n        this.internalSuccessMessages.length > 0 ||\n        this.success\n      )\n    },\n    externalError (): boolean {\n      return this.internalErrorMessages.length > 0 || this.error\n    },\n    hasMessages (): boolean {\n      return this.validationTarget.length > 0\n    },\n    hasState (): boolean {\n      if (this.disabled) return false\n\n      return (\n        this.hasSuccess ||\n        (this.shouldValidate && this.hasError)\n      )\n    },\n    internalErrorMessages (): VuetifyRuleValidations {\n      return this.genInternalMessages(this.errorMessages)\n    },\n    internalMessages (): VuetifyRuleValidations {\n      return this.genInternalMessages(this.messages)\n    },\n    internalSuccessMessages (): VuetifyRuleValidations {\n      return this.genInternalMessages(this.successMessages)\n    },\n    internalValue: {\n      get (): unknown {\n        return this.lazyValue\n      },\n      set (val: any) {\n        this.lazyValue = val\n\n        this.$emit('input', val)\n      },\n    },\n    shouldValidate (): boolean {\n      if (this.externalError) return true\n      if (this.isResetting) return false\n\n      return this.validateOnBlur\n        ? this.hasFocused && !this.isFocused\n        : (this.hasInput || this.hasFocused)\n    },\n    validations (): VuetifyRuleValidations {\n      return this.validationTarget.slice(0, Number(this.errorCount))\n    },\n    validationState (): string | undefined {\n      if (this.disabled) return undefined\n      if (this.hasError && this.shouldValidate) return 'error'\n      if (this.hasSuccess) return 'success'\n      if (this.hasColor) return this.computedColor\n      return undefined\n    },\n    validationTarget (): VuetifyRuleValidations {\n      if (this.internalErrorMessages.length > 0) {\n        return this.internalErrorMessages\n      } else if (this.successMessages.length > 0) {\n        return this.internalSuccessMessages\n      } else if (this.messages.length > 0) {\n        return this.internalMessages\n      } else if (this.shouldValidate) {\n        return this.errorBucket\n      } else return []\n    },\n  },\n\n  watch: {\n    rules: {\n      handler (newVal, oldVal) {\n        if (deepEqual(newVal, oldVal)) return\n        this.validate()\n      },\n      deep: true,\n    },\n    internalValue () {\n      // If it's the first time we're setting input,\n      // mark it with hasInput\n      this.hasInput = true\n      this.validateOnBlur || this.$nextTick(this.validate)\n    },\n    isFocused (val) {\n      // Should not check validation\n      // if disabled\n      if (\n        !val &&\n        !this.disabled\n      ) {\n        this.hasFocused = true\n        this.validateOnBlur && this.validate()\n      }\n    },\n    isResetting () {\n      setTimeout(() => {\n        this.hasInput = false\n        this.hasFocused = false\n        this.isResetting = false\n        this.validate()\n      }, 0)\n    },\n    hasError (val) {\n      if (this.shouldValidate) {\n        this.$emit('update:error', val)\n      }\n    },\n    value (val) {\n      this.lazyValue = val\n    },\n  },\n\n  beforeMount () {\n    this.validate()\n  },\n\n  created () {\n    this.form && this.form.register(this)\n  },\n\n  beforeDestroy () {\n    this.form && this.form.unregister(this)\n  },\n\n  methods: {\n    genInternalMessages (messages: VuetifyMessage): VuetifyRuleValidations {\n      if (!messages) return []\n      else if (Array.isArray(messages)) return messages\n      else return [messages]\n    },\n    /** @public */\n    reset () {\n      this.isResetting = true\n      this.internalValue = Array.isArray(this.internalValue)\n        ? []\n        : undefined\n    },\n    /** @public */\n    resetValidation () {\n      this.isResetting = true\n    },\n    /** @public */\n    validate (force = false, value?: any): boolean {\n      const errorBucket = []\n      value = value || this.internalValue\n\n      if (force) this.hasInput = this.hasFocused = true\n\n      for (let index = 0; index < this.rules.length; index++) {\n        const rule = this.rules[index]\n        const valid = typeof rule === 'function' ? rule(value) : rule\n\n        if (typeof valid === 'string') {\n          errorBucket.push(valid)\n        } else if (typeof valid !== 'boolean') {\n          consoleError(`Rules should return a string or boolean, received '${typeof valid}' instead`, this)\n        }\n      }\n\n      this.errorBucket = errorBucket\n      this.valid = errorBucket.length === 0\n\n      return this.valid\n    },\n  },\n})\n"],"sourceRoot":""}]}
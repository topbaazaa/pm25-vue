{"remainingRequest":"C:\\Users\\Acer\\Desktop\\pmm\\pm25-vue\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Acer\\Desktop\\pmm\\pm25-vue\\node_modules\\vuetify\\lib\\directives\\ripple\\index.js","dependencies":[{"path":"C:\\Users\\Acer\\Desktop\\pmm\\pm25-vue\\node_modules\\vuetify\\lib\\directives\\ripple\\index.js","mtime":499162500000},{"path":"C:\\Users\\Acer\\Desktop\\pmm\\pm25-vue\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Acer\\Desktop\\pmm\\pm25-vue\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["// Styles\nimport \"../../../src/directives/ripple/VRipple.sass\";\nimport { consoleWarn } from '../../util/console';\n\nfunction transform(el, value) {\n  el.style['transform'] = value;\n  el.style['webkitTransform'] = value;\n}\n\nfunction opacity(el, value) {\n  el.style['opacity'] = value.toString();\n}\n\nfunction isTouchEvent(e) {\n  return e.constructor.name === 'TouchEvent';\n}\n\nconst calculate = (e, el, value = {}) => {\n  const offset = el.getBoundingClientRect();\n  const target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;\n  const localX = target.clientX - offset.left;\n  const localY = target.clientY - offset.top;\n  let radius = 0;\n  let scale = 0.3;\n\n  if (el._ripple && el._ripple.circle) {\n    scale = 0.15;\n    radius = el.clientWidth / 2;\n    radius = value.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4;\n  } else {\n    radius = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2;\n  }\n\n  const centerX = `${(el.clientWidth - radius * 2) / 2}px`;\n  const centerY = `${(el.clientHeight - radius * 2) / 2}px`;\n  const x = value.center ? centerX : `${localX - radius}px`;\n  const y = value.center ? centerY : `${localY - radius}px`;\n  return {\n    radius,\n    scale,\n    x,\n    y,\n    centerX,\n    centerY\n  };\n};\n\nconst ripples = {\n  /* eslint-disable max-statements */\n  show(e, el, value = {}) {\n    if (!el._ripple || !el._ripple.enabled) {\n      return;\n    }\n\n    const container = document.createElement('span');\n    const animation = document.createElement('span');\n    container.appendChild(animation);\n    container.className = 'v-ripple__container';\n\n    if (value.class) {\n      container.className += ` ${value.class}`;\n    }\n\n    const {\n      radius,\n      scale,\n      x,\n      y,\n      centerX,\n      centerY\n    } = calculate(e, el, value);\n    const size = `${radius * 2}px`;\n    animation.className = 'v-ripple__animation';\n    animation.style.width = size;\n    animation.style.height = size;\n    el.appendChild(container);\n    const computed = window.getComputedStyle(el);\n\n    if (computed && computed.position === 'static') {\n      el.style.position = 'relative';\n      el.dataset.previousPosition = 'static';\n    }\n\n    animation.classList.add('v-ripple__animation--enter');\n    animation.classList.add('v-ripple__animation--visible');\n    transform(animation, `translate(${x}, ${y}) scale3d(${scale},${scale},${scale})`);\n    opacity(animation, 0);\n    animation.dataset.activated = String(performance.now());\n    setTimeout(() => {\n      animation.classList.remove('v-ripple__animation--enter');\n      animation.classList.add('v-ripple__animation--in');\n      transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);\n      opacity(animation, 0.25);\n    }, 0);\n  },\n\n  hide(el) {\n    if (!el || !el._ripple || !el._ripple.enabled) return;\n    const ripples = el.getElementsByClassName('v-ripple__animation');\n    if (ripples.length === 0) return;\n    const animation = ripples[ripples.length - 1];\n    if (animation.dataset.isHiding) return;else animation.dataset.isHiding = 'true';\n    const diff = performance.now() - Number(animation.dataset.activated);\n    const delay = Math.max(250 - diff, 0);\n    setTimeout(() => {\n      animation.classList.remove('v-ripple__animation--in');\n      animation.classList.add('v-ripple__animation--out');\n      opacity(animation, 0);\n      setTimeout(() => {\n        const ripples = el.getElementsByClassName('v-ripple__animation');\n\n        if (ripples.length === 1 && el.dataset.previousPosition) {\n          el.style.position = el.dataset.previousPosition;\n          delete el.dataset.previousPosition;\n        }\n\n        animation.parentNode && el.removeChild(animation.parentNode);\n      }, 300);\n    }, delay);\n  }\n\n};\n\nfunction isRippleEnabled(value) {\n  return typeof value === 'undefined' || !!value;\n}\n\nfunction rippleShow(e) {\n  const value = {};\n  const element = e.currentTarget;\n  if (!element || !element._ripple || element._ripple.touched) return;\n\n  if (isTouchEvent(e)) {\n    element._ripple.touched = true;\n    element._ripple.isTouch = true;\n  } else {\n    // It's possible for touch events to fire\n    // as mouse events on Android/iOS, this\n    // will skip the event call if it has\n    // already been registered as touch\n    if (element._ripple.isTouch) return;\n  }\n\n  value.center = element._ripple.centered;\n\n  if (element._ripple.class) {\n    value.class = element._ripple.class;\n  }\n\n  ripples.show(e, element, value);\n}\n\nfunction rippleHide(e) {\n  const element = e.currentTarget;\n  if (!element) return;\n  window.setTimeout(() => {\n    if (element._ripple) {\n      element._ripple.touched = false;\n    }\n  });\n  ripples.hide(element);\n}\n\nfunction updateRipple(el, binding, wasEnabled) {\n  const enabled = isRippleEnabled(binding.value);\n\n  if (!enabled) {\n    ripples.hide(el);\n  }\n\n  el._ripple = el._ripple || {};\n  el._ripple.enabled = enabled;\n  const value = binding.value || {};\n\n  if (value.center) {\n    el._ripple.centered = true;\n  }\n\n  if (value.class) {\n    el._ripple.class = binding.value.class;\n  }\n\n  if (value.circle) {\n    el._ripple.circle = value.circle;\n  }\n\n  if (enabled && !wasEnabled) {\n    el.addEventListener('touchstart', rippleShow, {\n      passive: true\n    });\n    el.addEventListener('touchend', rippleHide, {\n      passive: true\n    });\n    el.addEventListener('touchcancel', rippleHide);\n    el.addEventListener('mousedown', rippleShow);\n    el.addEventListener('mouseup', rippleHide);\n    el.addEventListener('mouseleave', rippleHide); // Anchor tags can be dragged, causes other hides to fail - #1537\n\n    el.addEventListener('dragstart', rippleHide, {\n      passive: true\n    });\n  } else if (!enabled && wasEnabled) {\n    removeListeners(el);\n  }\n}\n\nfunction removeListeners(el) {\n  el.removeEventListener('mousedown', rippleShow);\n  el.removeEventListener('touchstart', rippleHide);\n  el.removeEventListener('touchend', rippleHide);\n  el.removeEventListener('touchcancel', rippleHide);\n  el.removeEventListener('mouseup', rippleHide);\n  el.removeEventListener('mouseleave', rippleHide);\n  el.removeEventListener('dragstart', rippleHide);\n}\n\nfunction directive(el, binding, node) {\n  updateRipple(el, binding, false);\n\n  if (process.env.NODE_ENV === 'development') {\n    // warn if an inline element is used, waiting for el to be in the DOM first\n    node.context && node.context.$nextTick(() => {\n      const computed = window.getComputedStyle(el);\n\n      if (computed && computed.display === 'inline') {\n        const context = node.fnOptions ? [node.fnOptions, node.context] : [node.componentInstance];\n        consoleWarn('v-ripple can only be used on block-level elements', ...context);\n      }\n    });\n  }\n}\n\nfunction unbind(el) {\n  delete el._ripple;\n  removeListeners(el);\n}\n\nfunction update(el, binding) {\n  if (binding.value === binding.oldValue) {\n    return;\n  }\n\n  const wasEnabled = isRippleEnabled(binding.oldValue);\n  updateRipple(el, binding, wasEnabled);\n}\n\nexport const Ripple = {\n  bind: directive,\n  unbind,\n  update\n};\nexport default Ripple;",{"version":3,"sources":["../../../src/directives/ripple/index.ts"],"names":[],"mappings":"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","sourcesContent":["// Styles\nimport './VRipple.sass'\n\nimport { VNode, VNodeDirective } from 'vue'\nimport { consoleWarn } from '../../util/console'\n\nfunction transform (el: HTMLElement, value: string) {\n  el.style['transform'] = value\n  el.style['webkitTransform'] = value\n}\n\nfunction opacity (el: HTMLElement, value: number) {\n  el.style['opacity'] = value.toString()\n}\n\nexport interface RippleOptions {\n  class?: string\n  center?: boolean\n  circle?: boolean\n}\n\nfunction isTouchEvent (e: MouseEvent | TouchEvent): e is TouchEvent {\n  return e.constructor.name === 'TouchEvent'\n}\n\nconst calculate = (e: MouseEvent | TouchEvent, el: HTMLElement, value: RippleOptions = {}) => {\n  const offset = el.getBoundingClientRect()\n  const target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e\n  const localX = target.clientX - offset.left\n  const localY = target.clientY - offset.top\n\n  let radius = 0\n  let scale = 0.3\n  if (el._ripple && el._ripple.circle) {\n    scale = 0.15\n    radius = el.clientWidth / 2\n    radius = value.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4\n  } else {\n    radius = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2\n  }\n\n  const centerX = `${(el.clientWidth - (radius * 2)) / 2}px`\n  const centerY = `${(el.clientHeight - (radius * 2)) / 2}px`\n\n  const x = value.center ? centerX : `${localX - radius}px`\n  const y = value.center ? centerY : `${localY - radius}px`\n\n  return { radius, scale, x, y, centerX, centerY }\n}\n\nconst ripples = {\n  /* eslint-disable max-statements */\n  show (e: MouseEvent | TouchEvent, el: HTMLElement, value: RippleOptions = {}) {\n    if (!el._ripple || !el._ripple.enabled) {\n      return\n    }\n\n    const container = document.createElement('span')\n    const animation = document.createElement('span')\n\n    container.appendChild(animation)\n    container.className = 'v-ripple__container'\n\n    if (value.class) {\n      container.className += ` ${value.class}`\n    }\n\n    const { radius, scale, x, y, centerX, centerY } = calculate(e, el, value)\n\n    const size = `${radius * 2}px`\n    animation.className = 'v-ripple__animation'\n    animation.style.width = size\n    animation.style.height = size\n\n    el.appendChild(container)\n\n    const computed = window.getComputedStyle(el)\n    if (computed && computed.position === 'static') {\n      el.style.position = 'relative'\n      el.dataset.previousPosition = 'static'\n    }\n\n    animation.classList.add('v-ripple__animation--enter')\n    animation.classList.add('v-ripple__animation--visible')\n    transform(animation, `translate(${x}, ${y}) scale3d(${scale},${scale},${scale})`)\n    opacity(animation, 0)\n    animation.dataset.activated = String(performance.now())\n\n    setTimeout(() => {\n      animation.classList.remove('v-ripple__animation--enter')\n      animation.classList.add('v-ripple__animation--in')\n      transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`)\n      opacity(animation, 0.25)\n    }, 0)\n  },\n\n  hide (el: HTMLElement | null) {\n    if (!el || !el._ripple || !el._ripple.enabled) return\n\n    const ripples = el.getElementsByClassName('v-ripple__animation')\n\n    if (ripples.length === 0) return\n    const animation = ripples[ripples.length - 1]\n\n    if (animation.dataset.isHiding) return\n    else animation.dataset.isHiding = 'true'\n\n    const diff = performance.now() - Number(animation.dataset.activated)\n    const delay = Math.max(250 - diff, 0)\n\n    setTimeout(() => {\n      animation.classList.remove('v-ripple__animation--in')\n      animation.classList.add('v-ripple__animation--out')\n      opacity(animation, 0)\n\n      setTimeout(() => {\n        const ripples = el.getElementsByClassName('v-ripple__animation')\n        if (ripples.length === 1 && el.dataset.previousPosition) {\n          el.style.position = el.dataset.previousPosition\n          delete el.dataset.previousPosition\n        }\n\n        animation.parentNode && el.removeChild(animation.parentNode)\n      }, 300)\n    }, delay)\n  },\n}\n\nfunction isRippleEnabled (value: any): value is true {\n  return typeof value === 'undefined' || !!value\n}\n\nfunction rippleShow (e: MouseEvent | TouchEvent) {\n  const value: RippleOptions = {}\n  const element = e.currentTarget as HTMLElement\n  if (!element || !element._ripple || element._ripple.touched) return\n  if (isTouchEvent(e)) {\n    element._ripple.touched = true\n    element._ripple.isTouch = true\n  } else {\n    // It's possible for touch events to fire\n    // as mouse events on Android/iOS, this\n    // will skip the event call if it has\n    // already been registered as touch\n    if (element._ripple.isTouch) return\n  }\n  value.center = element._ripple.centered\n  if (element._ripple.class) {\n    value.class = element._ripple.class\n  }\n  ripples.show(e, element, value)\n}\n\nfunction rippleHide (e: Event) {\n  const element = e.currentTarget as HTMLElement | null\n  if (!element) return\n\n  window.setTimeout(() => {\n    if (element._ripple) {\n      element._ripple.touched = false\n    }\n  })\n  ripples.hide(element)\n}\n\nfunction updateRipple (el: HTMLElement, binding: VNodeDirective, wasEnabled: boolean) {\n  const enabled = isRippleEnabled(binding.value)\n  if (!enabled) {\n    ripples.hide(el)\n  }\n  el._ripple = el._ripple || {}\n  el._ripple.enabled = enabled\n  const value = binding.value || {}\n  if (value.center) {\n    el._ripple.centered = true\n  }\n  if (value.class) {\n    el._ripple.class = binding.value.class\n  }\n  if (value.circle) {\n    el._ripple.circle = value.circle\n  }\n  if (enabled && !wasEnabled) {\n    el.addEventListener('touchstart', rippleShow, { passive: true })\n    el.addEventListener('touchend', rippleHide, { passive: true })\n    el.addEventListener('touchcancel', rippleHide)\n\n    el.addEventListener('mousedown', rippleShow)\n    el.addEventListener('mouseup', rippleHide)\n    el.addEventListener('mouseleave', rippleHide)\n    // Anchor tags can be dragged, causes other hides to fail - #1537\n    el.addEventListener('dragstart', rippleHide, { passive: true })\n  } else if (!enabled && wasEnabled) {\n    removeListeners(el)\n  }\n}\n\nfunction removeListeners (el: HTMLElement) {\n  el.removeEventListener('mousedown', rippleShow)\n  el.removeEventListener('touchstart', rippleHide)\n  el.removeEventListener('touchend', rippleHide)\n  el.removeEventListener('touchcancel', rippleHide)\n  el.removeEventListener('mouseup', rippleHide)\n  el.removeEventListener('mouseleave', rippleHide)\n  el.removeEventListener('dragstart', rippleHide)\n}\n\nfunction directive (el: HTMLElement, binding: VNodeDirective, node: VNode) {\n  updateRipple(el, binding, false)\n\n  if (process.env.NODE_ENV === 'development') {\n    // warn if an inline element is used, waiting for el to be in the DOM first\n    node.context && node.context.$nextTick(() => {\n      const computed = window.getComputedStyle(el)\n      if (computed && computed.display === 'inline') {\n        const context = (node as any).fnOptions ? [(node as any).fnOptions, node.context] : [node.componentInstance]\n        consoleWarn('v-ripple can only be used on block-level elements', ...context)\n      }\n    })\n  }\n}\n\nfunction unbind (el: HTMLElement) {\n  delete el._ripple\n  removeListeners(el)\n}\n\nfunction update (el: HTMLElement, binding: VNodeDirective) {\n  if (binding.value === binding.oldValue) {\n    return\n  }\n\n  const wasEnabled = isRippleEnabled(binding.oldValue)\n  updateRipple(el, binding, wasEnabled)\n}\n\nexport const Ripple = {\n  bind: directive,\n  unbind,\n  update,\n}\n\nexport default Ripple\n"],"sourceRoot":""}]}